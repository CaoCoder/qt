#  时间复杂度1和

##  消失的数字——位运算符法（异或）

0和n+1个数异或，n+1个数还是原来的样子，主要是要和2n+1的数再次异或，(相同为0，相异为1，0异或0还是0)得到缺失的数字。

```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int ret = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            ret = ret ^ nums[i];
        }
        for(int i = 0; i < nums.size()+1; i++)
        {
            ret = ret ^ i;
        }
        return ret;
    }
};
```

##  消失的数字——哈希写法(unordered_set)

```c
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        unordered_set<int> set;
        int n = nums.size();
        for(int i = 0; i < n; i++)
        {
            set.insert(nums[i]);
        }
        int missing = -1;
        for(int i = 0; i <= n; i++)
        {
            if(!set.count(i))
            {
                missing = i;
            }
        }
         return missing;
    }
       
};  
```

##  只出现一次的数



直接异或

```c
class Solution {
public:
    int singleNumber(vector<int>& nums) 
    {
        int ret = 0;
        int n = nums.size();
        for(int i = 0; i < n; i++)
        {
            ret = ret ^ nums[i];
        }
        return ret;
    }
};
```

##  轮转数组 ——只能用O(n)的空间



注意边界问题，特别是轮转多少。还有边界分割。

```c
class Solution {
public:
    void rotate1(vector<int>& nums, int left, int right)
    {
        
        int ret = 0;

        while(left < right)
        {
            ret = nums[left];
            nums[left] = nums[right];
            nums[right] = ret;
            left++;
            right--;
        }

    }
    void rotate(vector<int>& nums, int k) {
            while(k > nums.size())
            {
                k = k  % nums.size();
            }
            rotate1(nums, 0, nums.size() - 1);
            rotate1(nums, 0, k-1);
            rotate1(nums, k, nums.size() - 1);

    }
};
```

##  移除元素——(双指针法)

思路：

left指针管理输出的数组。

right管理输入的数组。right指针负责把不等于 val的值，全部输入到left管理的数组中

```c
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
       int left = 0;
        int  n = nums.size();
        int right = 0;
        for(int i = 0; i < n; i++)
        {
            if(nums[right] != val)
            {
                nums[left] = nums[right];
                left++;
                right++;
            }
            else
            {
                right++;
            }
        }
        return left;
    }
};
```

