#  括号匹配问题

```c++
class Solution {
public:
    bool isValid(string s) 
    {
        stack<char> st;
        for(int i = 0; i < s.size(); i++)
        {
            
            if(s[i] == '(' || s[i] == '[' || s[i] == '{')
            {
                st.push(s[i]);
            }
            else
            {
                    if(st.empty())
                    {
                        return false;
                    }
                    else if(st.top() == '(' && s[i] == ')')
                    {
                        st.pop();
                    }
                    else if(st.top() == '{' && s[i] == '}')
                    {
                        st.pop();
                    }
                    else if(st.top() == '[' && s[i] == ']')
                    {
                        st.pop();
                    }
                    else
                    {
                        return false;
                    }   
            }
            
        }

        if(!st.empty())
        {
            return false;
        }    
        else{
            return true;
        }
    }
};
```

#  用两个队列模拟 栈

```c++
class MyStack {
public:
    queue<int> q1;
    queue<int> q2;
    MyStack() {
    
    }
   
   
    void push(int x) 
    {
        
        if(q1.empty())
        {
            q2.push(x);
        }
        else
        {
            q1.push(x);
        }
        
    }
    
    int pop() 
    {
        if(!empty())
        {
            if(q2.empty())
        {
             int sz = q1.size()-1;
             while(sz--)
             {
                q2.push(q1.front());
                q1.pop();
             }
             int tmp = q1.front();
             q1.pop();

             return tmp;
        }
        else
        {
            int sz = q2.size()-1;
             while(sz--)
             {
                q1.push(q2.front());
                q2.pop();
             }
              int tmp = q2.front();
             q2.pop();
             return tmp;
        }
        }

        return 0;
        
    }
    
    int top() 
    {
        if(empty())
        {
            return 0;
        }
        if(q2.empty())
        {
            return q1.back();
        }
        else
        {
            return q2.back();
        }
    }
    
    bool empty() {
        if(q1.empty() && q2.empty())
        {
            return true;
        }
        else
        {
            return false;
        }
    }
};


```

##  用两个栈实现队列



和两个队列实现栈不同，需要转到另一个栈之后，再转回来。这是自己的笨方法

```c++
class MyQueue {
public:

    stack<int> st1;
    stack<int> st2;
    MyQueue() {

    }
   
    void push(int x) {
        if(!st1.empty())
        {
            st1.push(x);
        }
        else
        {
            st2.push(x);
        }
    }
    
    int pop() {
        if(!empty())
        {   
            int tmp = 0;
            if(st2.empty())
            {
            int sz = st1.size() - 1;
            while(sz--)
            {
                    st2.push(st1.top());
                    st1.pop();
            }
            tmp = st1.top();
            st1.pop();
          
            }
            else
            {
                int sz = st2.size() - 1;
                while(sz--)
                {
                        st1.push(st2.top());
                        st2.pop();
                }
                tmp = st2.top();
                st2.pop();
                
            }

             if(st2.empty())
            {
            int sz = st1.size();
            while(sz--)
            {
                    st2.push(st1.top());
                    st1.pop();
            }
          
            }
            else
            {
                int sz = st2.size();
                while(sz--)
                {
                        st1.push(st2.top());
                        st2.pop();
                }

            }

            return tmp;
        }
        return 0;
        
    }
    
    int peek() {
        if(!empty())
        {
            int tmp = 0;
            if(st2.empty())
            {
                 int sz = st1.size() - 1;
                while(sz--)
                {
                        st2.push(st1.top());
                        st1.pop();
                }
                tmp = st1.top();
                st2.push(st1.top());
                st1.pop();
                
            }
            else
            {
                int sz = st2.size() - 1;
                while(sz--)
                {
                        st1.push(st2.top());
                        st2.pop();
                }
                tmp = st2.top();
                st1.push(st2.top());
                st2.pop();
                
            }
             if(st2.empty())
            {
                int sz = st1.size();
                while(sz--)
                {
                        st2.push(st1.top());
                        st1.pop();
                }
                
            }
            else
            {
                int sz = st2.size();
                while(sz--)
                {
                        st1.push(st2.top());
                        st2.pop();
                }
    
            }
           return tmp;
        }
        return 0;

    }
    
    bool empty() {
        if(st1.empty() && st2.empty())
        {
            return true;
        }
        else
        {
            return false;
        }
    }
};


```

##  标准题解

一个栈用来进行入栈，一个栈用来出栈。

```c++
class MyQueue {
private:
    stack<int> inStack, outStack;

    void in2out() {
        while (!inStack.empty()) {
            outStack.push(inStack.top());
            inStack.pop();
        }
    }

public:
    MyQueue() {}

    void push(int x) {
        inStack.push(x);
    }

    int pop() {
        if (outStack.empty()) {
            in2out();
        }
        int x = outStack.top();
        outStack.pop();
        return x;
    }

    int peek() {
        if (outStack.empty()) {
            in2out();
        }
        return outStack.top();
    }

    bool empty() {
        return inStack.empty() && outStack.empty();
    }
};

作者：力扣官方题解
链接：https://leetcode.cn/problems/implement-queue-using-stacks/solutions/632369/yong-zhan-shi-xian-dui-lie-by-leetcode-s-xnb6/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

