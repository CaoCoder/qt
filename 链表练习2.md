#  链表练习2

##  返回倒数第k个结点。



```c++
class Solution {
public:
    int kthToLast(ListNode* head, int k)
    {
        ListNode* cur = head;
        int c = 0;
        while(cur != NULL)
        {
            ++c;
            cur = cur->next;
        }

        c = c - k;
        for(int i = 0; i < c; i++)
        {
            head = head->next;
        }
        return head->val;
    }
};
```

##  合并有序链表

注意边界点。

1.可以不使用多次循环，一次就够了，能直接连接就直接连接。

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) 
    {
        ListNode* dummy = new ListNode(0);
        ListNode* cur = dummy;
        while(list1 != nullptr && list2 != nullptr)
        {
            if(list2->val <= list1->val)
            {
                cur->next = list2;
                cur = cur->next;
                list2 = list2->next;
            }
            else
            {
                cur->next = list1;
                cur = cur->next;
                list1 = list1->next;
            }
        }
        if(list1 == nullptr)
        {     
                cur->next = list2;       
        }
        else
        {
                cur->next = list1;
        }
    
        

        return dummy->next;

        delete dummy;

    }
    
};
```

##   链表分割

注意链表的每个结点连接上去的末尾要设置为NULL，因为末尾不一定是NULL。

```c++
class Partition {
public:
    ListNode* partition(ListNode* pHead, int x) {
        // write code here

        ListNode* list1 = new ListNode(0);
        ListNode* c1 = list1 ;
        ListNode* list2 = new ListNode(0);
        ListNode* c2 = list2 ;

        ListNode* cur = pHead;
        while(cur != NULL)
        {
            if(cur->val < x)
            {
                //小于x的节点
                c1->next = cur;
                c1 = c1->next;
            }
            else 
            {
                c2->next= cur;
                c2 = c2->next;
            }
            cur = cur->next;
        }
        // c1->next = NULL;//注意list1的末尾可能是NULL
      
        // c1 = list1;
        // while(c1->next != NULL)
        // {
        //     c1= c1->next;
        // }
        c1->next = list2->next;
        
        c2->next = NULL;

        ListNode* tmp = list1->next;

        delete list1;
        delete list2;
        
        return tmp;
    }
};
```

